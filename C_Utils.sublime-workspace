{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"MU_Haz",
				"MU_Hazard_Pointer_release"
			],
			[
				"MU_LOG",
				"MU_LOG_TRACE"
			],
			[
				"retire",
				"retire"
			],
			[
				"curr",
				"curr_index"
			],
			[
				"MU_HA",
				"MU_HAZARD_POINTERS_MAX_THREADS"
			],
			[
				"MU_A",
				"MU_ARG_CHECK"
			],
			[
				"init",
				"init_tls_hp"
			],
			[
				"MU_Ha",
				"MU_Hazard_Pointer_t"
			],
			[
				"MU_Hazard_",
				"MU_Hazard_Pointer_reset"
			],
			[
				"haza",
				"hazard_table"
			],
			[
				"hazard",
				"hazard_pointers"
			],
			[
				"atomic",
				"atomic_compare_exchange_strong"
			],
			[
				"MU_HAz",
				"MU_Hazard_Pointer_t"
			],
			[
				"DS_Lis",
				"DS_List_create"
			],
			[
				"MU_HAZARD_POINTERS_MAX",
				"MU_HAZARD_POINTERS_MAX_PER_THREAD"
			],
			[
				"MU_HAZARD_POINT",
				"MU_HAZARD_POINTERS_MAX_THREADS"
			],
			[
				"MU_HAZ",
				"MU_HAZARD_POINTERS_MAX_THREAD_COUNT"
			],
			[
				"MU_HAZA",
				"MU_HAZARD_POINTERS_PER_THREAD"
			],
			[
				"MU_HP",
				"MU_HP_List_t"
			],
			[
				"DS_List",
				"DS_List_clear"
			],
			[
				"MU_Hazard",
				"MU_Hazard_Pointer_t"
			],
			[
				"MU_H",
				"MU_Hazard_Pointer_t"
			],
			[
				"DS_",
				"DS_delete_cb"
			],
			[
				"MU_",
				"MU_HAZARD_POINTERS_PER_THREAD"
			],
			[
				"MU_Event",
				"MU_Event_create"
			],
			[
				"MU_Event_loop",
				"MU_Event_Loop_t"
			],
			[
				"MU_Event_Source",
				"MU_Event_Source_t"
			],
			[
				"dispat",
				"dispatch_timer"
			],
			[
				"prepa",
				"prepare_timer"
			],
			[
				"disp",
				"dispatch_timer"
			],
			[
				"source",
				"source_two"
			],
			[
				"sour",
				"source_one"
			],
			[
				"dis",
				"dispatch_timer"
			],
			[
				"Linked_list",
				"Linked_List_next"
			],
			[
				"LInke",
				"Linked_List_head"
			],
			[
				"timeout",
				"timeout_time"
			],
			[
				"cur",
				"curr_source"
			],
			[
				"MU_FLAG",
				"MU_FLAG_GET"
			],
			[
				"dispa",
				"dispatch_string"
			],
			[
				"MU_Event_Sour",
				"MU_Event_Source_create"
			],
			[
				"pr",
				"prepare_iterator"
			],
			[
				"fina",
				"finalize"
			],
			[
				"MU_LOG_",
				"MU_LOG_ASSERT"
			],
			[
				"MU_Event_Lo",
				"MU_Event_Loop_t"
			],
			[
				"MU_event_Loop",
				"MU_Event_Loop_t"
			],
			[
				"text",
				"textarea	Tag"
			],
			[
				"get",
				"getElementById"
			],
			[
				"cook",
				"cookie_contents"
			],
			[
				"page",
				"page_size_len"
			],
			[
				"file",
				"filepath"
			],
			[
				"req",
				"req"
			],
			[
				"NU_HTTP_MET",
				"NU_HTTP_NO_METHOD"
			],
			[
				"NU_HTTP_VER",
				"NU_HTTP_NO_VER"
			],
			[
				"ver",
				"version"
			],
			[
				"NU_HTTP_VE",
				"NU_HTTP_VER_1_0"
			],
			[
				"NU_HTTP_",
				"NU_HTTP_TRACE"
			],
			[
				"header",
				"header_size"
			],
			[
				"for",
				"for	For Loop"
			],
			[
				"head",
				"header_size"
			],
			[
				"NU_HTTP_FIEL",
				"NU_HTTP_HEADER_FIELD_LEN"
			],
			[
				"tu",
				"trunc_key"
			],
			[
				"mapped",
				"mapped_fields"
			],
			[
				"MU_COND_M",
				"MU_COND_MUTEX_DESTROY"
			],
			[
				"MU_COND",
				"MU_COND_MUTEX_LOCK"
			],
			[
				"MU_Cond",
				"MU_COND_MUTEX_UNLOCK"
			],
			[
				"MU_CONDMU",
				"MU_COND_MUTEX_LOCK"
			],
			[
				"bsock",
				"bsock_unbind"
			],
			[
				"MU_RE",
				"MU_TEMP_FAILURE_RETRY"
			],
			[
				"MU_Co",
				"MU_COND_MUTEX_UNLOCK"
			],
			[
				"MU_COND_MU",
				"MU_COND_MUTEX_LOCK"
			],
			[
				"handl",
				"handle_connection"
			],
			[
				"arg",
				"arg_size"
			],
			[
				"SU_S",
				"SU_String_starts_with"
			],
			[
				"SU_String_",
				"SU_String_substring"
			],
			[
				"s",
				"s"
			],
			[
				"logger",
				"logger"
			],
			[
				"MU",
				"MU_TEST_H"
			],
			[
				"start",
				"start_str"
			],
			[
				"start_",
				"start_offset"
			],
			[
				"char",
				"char_equal"
			],
			[
				"SU_STr",
				"SU_String_equal"
			],
			[
				"substr",
				"substring"
			],
			[
				"buf",
				"buf_size"
			],
			[
				"string",
				"string_ptr"
			],
			[
				"to",
				"tolower"
			],
			[
				"find",
				"find_len"
			],
			[
				"split",
				"split_strings"
			],
			[
				"ignore",
				"ignore_case"
			],
			[
				"DS_Atomic_",
				"DS_Atomic_Node_create"
			],
			[
				"DS",
				"DS_Stack_t"
			],
			[
				"DS_Stack",
				"DS_Stack_t"
			],
			[
				"DS_A",
				"DS_Atomic_Node_t"
			],
			[
				"DS_At",
				"DS_Atomic_Node_create"
			],
			[
				"atomic_compare",
				"atomic_compare_exchange_strong"
			],
			[
				"atomic_",
				"atomic_compare_exchange_weak"
			],
			[
				"DS_Ato",
				"DS_Atomic_Node_t"
			],
			[
				"DS_Atom",
				"DS_Atomic_Node_create"
			],
			[
				"DS_Nod",
				"DS_Atomic_Node_t"
			],
			[
				"MU_L",
				"MU_LOG_ASSERT"
			],
			[
				"DS_Queue",
				"DS_Queue_t"
			],
			[
				"ret",
				"retval"
			],
			[
				"event",
				"event_signal"
			],
			[
				"thread",
				"thread_id"
			],
			[
				"TP_Pool_",
				"TP_Pool_resume"
			],
			[
				"Des",
				"Destroy_Worker"
			],
			[
				"sleep",
				"sleep_after"
			],
			[
				"max_",
				"max_num"
			],
			[
				"not",
				"not_empty"
			],
			[
				"pthread_cond",
				"pthread_cond_broadcast"
			],
			[
				"atomic_fe",
				"atomic_fetch_add"
			],
			[
				"pthread",
				"pthread_cond_timedwait"
			],
			[
				"max",
				"max_size"
			],
			[
				"DS_PB",
				"DS_PBQueue_t"
			],
			[
				"not_empty",
				"not_empty_init"
			],
			[
				"Add_as_",
				"Add_As_Tail"
			],
			[
				"Dest",
				"Destroy_Task"
			],
			[
				"tp",
				"tp"
			],
			[
				"result",
				"result_event_name"
			],
			[
				"finis",
				"finished_event_name"
			],
			[
				"pause",
				"pause_event_name"
			],
			[
				"worker",
				"worker_threads"
			],
			[
				"pool",
				"pool_size"
			],
			[
				"MU_EVE",
				"MU_EVENT_MAX_LEN"
			],
			[
				"even",
				"event_name_len"
			],
			[
				"seconds",
				"seconds_to_pause"
			],
			[
				"cond",
				"cond_initialized"
			],
			[
				"lock",
				"lock_initialized"
			],
			[
				"MU_E",
				"MU_Event_t"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "# Utilities Package for the C Programming Language\n\n##Summary\n\nUtilities Package for the C Programming Language, or C_Utils for short, is my attempt at providing a full fledged package of various libraries ranging from thread-safe (some lockless) data structures, to a Thread Pool, to an HTTP parser, to a simple event loop implementation (and separate Win32 Event implementations for POSIX), etc.\n\nC_Utils is essentially my personal playground, where if I wish to find out how something works internally, I implement and/or reverse-engineer it into being. Yes, it is reinventing the wheel, but when that wheel can be infinite as the universe itself, what's the harm in knowing more about them?\n\nC_Utils may never actually be finished, for as long I have something I wish to learn about at a lower level, I will add and implement it here, however to date I have put in over 500 hours since I started it this summer (2015), and I plan on continuing developing this utilities package.\n\n##About the Author\n\nI a late-but-upcoming Computer Science major who's developed more than a bit of a fascination into the world of computing, data structures, algorithms, and all other wonders modern technology brings. While I am rather late to the game, it doesn't make me any less willing to learn, as I use this utilities package as my personal playground.\n\n##Notes\n\n[<b>Unimplemented</b>] means it has not been started at all but I am planning on implementing at a later date.\n\n[<b>In Development</b>] means that it is currently in development and should be finished soon.\n\n[<b>Unstable</b>] means I'm not sure if it's stable, but it's usable although not well tested.\n\n[<b>Stable</b>] means that it is stable enough to use, although features may be added later.\n\n[<b>Finished</b>] means that in all likely hood, I'll no longer work on it unless a bug presents itself.\n\n##Libraries available\n\n### Thread Pool [<b>In Development</b>]\n\n####Static Pool [<b>Stable</b>] Version: 1.2\n\nTP_Pool is a thread pool with it's own priority queue for tasks. As implied by the use of a priority queue, tasks may be submitted via 6 different priorities, Lowest, Low, Medium, High and Highest. High Priority tasks would jump ahead of tasks of Low priority, intuitively. \n\nThe static thread pool maintains a steady amount of threads, never growing or shrinking in size, however unused threads will block, hence it will not waste resources waiting for a new task to be submitted. \n\nEach task can return an asynchronous result, which, based on my implementation of events, you may wait (or poll) for when the task finishes. So, to reiterate, a task, by default, returns a result which can be waited on.\n\nWhen submitting tasks, it comes with it's own default priority and will return a TP_Result_t result to wait on, but by passing certain flags, like TP_HIGH_PRIORITY | TP_NO_RESULT you may flag tasks specifically.\n\nFinally you can pause the thread pool, meaning, that currently running tasks finish up, but it will not run any more until after either a timeout elapses or the call to resume is made.\n\nAnother note to mention is that the thread pool showcases the use of MU_Events, as waiting on a result is an event, so is to pause and resume. \n\nAn example of use of the thread pool is detailed below...\n\n```c\n\n/// Initialize a pool of 10 threads, enough to handle anything without wasting resources.\nstatic const size_t pool_size = 10;\n\n/// Example task for thread pool to run.\nstatic void *task_example(void *args);\n\nTP_Pool_t *tp = TP_Pool_create(pool_size);\n/// Adds a task of medium priority (default), with no argument (NULL) nor flags (0)\nTP_Result_t *result = TP_Pool_add(tp, task_example, NULL, 0);\n/// Adds the same task of high priority, no argument, and without a result.\nTP_Pool_add(tp, task_example, NULL, TP_HIGH_PRIORITY | TP_NO_RESULT);\n/// Note that you do not need to worry about cleaning up the result from TP_NO_RESULT.\n/// Wait on result with no timeout (-1).\nvoid *retval = TP_Result_get(result, -1);\n/// Destroy the result, as it no longer is needed.\nTP_Result_destroy(result);\n/// Pause the thread pool for 5 seconds.\nTP_Pool_pause(tp, 5);\n/// Wait on Thread Pool to finish everything.\nTP_Pool_wait(tp, -1);\n/// Destroy thread pool.\nTP_Pool_destroy(tp);\n\n```\n\nVery simple to use, very powerful as all thread pools are. By passing bit flags, it makes it easier to add newer features without adding more parameters and breaking things. It's fast, efficient and doesn't leak.\n\nVery Outdated: Documentation for version 1.1 available [here](http://theif519.github.io/Thread_Pool_Documentation/).\n\n####Dynamic Pool [<b>Unimplemented</b>]\n\n### String Utils [<b>Stable</b>] Version: 2.0\n\n####String Manipulations [<b>Stable</b>] Version: 2.0\n\nA basic, yet very powerful and conventional string manipulations library. Supports ASCII strings only, and some functions support the use of non NULL-terminated functions.\n\nFrom simple string reversal or splitting and joining a string based on a delimiter, or even dynamic concatenation of strings, is all included in this library. This library fixes and improves upon the standard libc and glibc library by adding functionality that is sorely missing, in an efficient manner.\n\nThere is also a convenience typedef for cstrings, String, which abstracts the need to use pointers. Lastly, there is a convenience macro that can be used to handle memory management of non-constant strings, TEMP, which utilitizes the GCC or Clang's compiler attributes.\n\nExamples of it's use can be seen below...\n\n```c\n\n/*\n    The below demonstrates the ease of use of declaring a string with the\n    typedef provided. Alternatively, you can declare it as char *str, which\n    can be used interchangeably.\n*/\nString str = \"Hello World\";\n/*\n    The below demonstrates the memory management of strings being handled by\n    the compiler, automatically being destroyed when it leaves the scope of the\n    block of code.\n*/\nString TEMP str = strdup(\"Hello World\");\n/*\n    Now, on to the actual functions of this string manipulation library.\n    First, we will attempt to reverse a portion of the string, str, declared\n    above. We only wish to reverse \"World\" however, so we will make use of\n    pointer arithmetic to get the offset of the string. We want to reverse\n    everything after after \"Hello \", so we pass 0 as the length to specify\n    that it is null terminated and that strlen can be used.\n*/\nSU_String_reverse(str + 6, 0);\n/*\n    Now, for the next example, imagine we have a fixed amount, but a somewhat\n    large amount of strings to concatenate together, and you not only wish to\n    concatenate them together, but also apply some kind of delimiter. For\n    instance, SU_String_split can split an array into an array of strings\n    based on a delimiter, and you wish to join them together with a new\n    delimiter. While SU_String_replace can do the job just as well (better),\n    lets assume you actually modify the array of strings somehow. You have\n    two options here, either SU_String_join, which is easier, but you need to\n    pass an array, but what if you wish to append a new string, then you have\n    resize the array (if it's not constant), or create an entirely new one.\n    Instead, SU_STRING_CONCAT_ALL allows you to concatenate any number of\n    strings with an optional delimiter.\n*/\nString storage;\nSU_STRING_CONCAT_ALL(&storage, \",\", str, \"How are you today\", \"Good I hope\", \"Good day!\");\n/*\n    The other functions are rather straight forward, however to go more into \n    SU_STRING_CONCAT_ALL, notice you do not need to add a NULL dummy parameter\n    or specify the size. That's because the preprocessor can determine it for\n    you, which it does.\n*/\n```\n\nSU_String is rather powerful, and also very simple. The String typedef makes it easier for programmers coming from other languages to read, the TEMP modifier helps with memory management, and the string manipulation functions are rather intuitive and easy to use. \n\nOUTDATED: Documentation for version 1.2 available [here](http://theif519.github.io/String_Utils_Documentation/).\n\n####Regular Expressions [<b>Unimplemented</b>]\n\n### File Utils [<b>Unimplemented</b>]\n\n### Networking Utils [<b>In Development</b>]\n\n####Connection [<b>Stable</b>] Version: 1.0\n\nNU_Connection is the base file for all transactions on sockets and between endpoints. It contains all sending and receiving functions and logs everything. It can be created manually through NU_Connection_create() and NU_Connection_init() but it's best created through the abstractions, NU_Server and NU_Client. \n\nTo send and receive data (as well as files) is rather simple. The examples below assume that the connection has been correctly configured and set up, most likely through NU_Server and NU_Client...\n\n```c\n\n/// Unlike normal bsd socket functions, my abstractions provide a timeout.\nconst int timeout = 60;\n/// The flags to be passed to send().\nconst int send_flags = 0;\n/// The flags to be passed to recv().\nconst int recv_flags = 0;\n\nNU_Connection_t *conn;\n/// Assume it's been setup and configured and already.\nchar buf[BUFSIZ];\nsize_t bytes_sent = NU_Connection_send(conn, buf, BUFSIZ, timeout, send_flags);\nassert(bytes_sent);\n// Simple error checking, assertions are easy for small programs.\nsize_t bytes_received = NU_Connection_receive(conn, buf, BUFSIZ, timeout, recv_flags);\nassert(bytes_sent);\nprintf(\"%.*s\", (int)bytes_received, buf);\n\n```\n\nNow wrap the function calls in a while loop and get user input to send, and you've got a simple server-client chat. It's rather simple, yet powerful, as all BSD socket applications are.\n\n####Server [<b>Stable</b>] Version: 1.0\n\nThe philosophy of the NU_Server is that it acts as a manager for NU_Connection objects, which are completely configured and connected to a client. The server also manages a resource and recycling pool of NU_Connection objects as well for after you disconnect them. The server also allows you to manage multiple bindings of ports. \n\nTo create a connection through NU_Server, see the following example...\n\n```c\n\n/// The initial connection pool size\nconst int connection_pool = 10;\n/// The initial bound socket pool size.\nconst int bound_socket_pool = 4;\n/// Whether or not locks are initialized. 0 for single-threaded or care multithreading.\nconst int is_threaded = 1;\n/// The IP address to bind to. If it is NULL, it is bound INADDR_ANY\nconst char *ip_addr = \"127.0.0.1\";\n/// Port to bind to.\nconst unsigned int port = 8000;\n/// Unlike normal bsd socket functions, my abstractions provide a timeout.\nconst int timeout = 60;\n\nNU_Server_t *server = NU_Server_create(connection_pool, bound_socket_pool, is_threaded);\n/// connection_pool used as backlog too.\nNU_Bound_Socket_t *bsock = NU_Server_bind(server, connection_pool, port, ip_addr);\nNU_Connection_t *conn = NU_Server_accept(server, bsock, timeout);\n\n```\n\nAnd that's it. When you are finished with bsock, call NU_Server_unbind(server, bsock). When you are finished with the connection, call NU_Server_disconnect(server, conn), and it will add them back to the resource pool so they can be reused.\n\n####Client [<b>Stable</b>] Version: 1.0\n\nThe philosophy of NU_Client follows NU_Server, in that it acts as a manager for NU_Connection objects, completely configured and initialized. Unlike the client, obviously, there is no need to bind to a port or create a bound socket type object. \n\nAn example can be seen below.\n\n```c\n\n/// The initial connection pool size\nconst int connection_pool = 10;\n/// Whether or not locks are initialized. 0 for single-threaded or care multithreading.\nconst int is_threaded = 1;\n/// The host's IP Address.\nconst char *ip_addr = \"127.0.0.1\";\n/// Port to bind to.\nconst unsigned int port = 8000;\n/// Unlike normal bsd socket functions, my abstractions provide a timeout.\nconst int timeout = 60;\n\nNU_Client_t *client = NU_Client_create(connection_pool, is_threaded);\nNU_Connection_t *conn = NU_Client_connect(client, ip_addr, port, timeout);\n\n```\n\nEven shorter than NU_Server is. Create the client and go. Just like NU_Server, if you are finished with a NU_Connection, call NU_Client_disconnect to add it back to the pool.\n\n####HTTP [<b>Unstable</b>] Version 0.5\n\nNU_HTTP, or Net_Utils's HTTP Parser, is a simple yet minimal parsing, and generating, HTTP library. It allows you to parse HTTP requests and responses, as well generate your own by setting fields, resposne statuses, etc. by the use of it's API.\n\nNU_HTTP takes a buffer, not having to be NULL-terimainted, and returns what's left in the buffer after it parses out the rest. Hence, if you pass both the HTTP header and the message body, it will return the offset (note here) of where the message body begins. It allows you to check if a field is set by using a hash table of it's field-value pairs, file path, response status, HTTP version, etc. \n\nLastly, it allows you to create an HTTP response or request in an elegant way. An example can be seen below...\n\n```c\n\n/// Assume header gets filled out by some request.\nchar header[BUFSIZ];\nsize_t request_size;\nNU_Request_t *req = NU_Request_create();\nNU_Request_append_header(req, header, &request_size);\nFILE *file = fopen(req->path, \"r\");\nNU_Response_t *res = NU_Response_create();\n/*\n    Note that it takes a rather elegant looking key-value pair, in the guise\n    of a struct with two char * members. What the macro does, in gist, is\n    that it takes (NU_Field_t){ x, y}, into { x, y} by converting it for you.\n    Hence (NU_Field_t){ \"Content-Length\", file_size } becomes a much better:\n    { \"Content-Length\", file_size }.\n*/\nNU_RESPONSE_WRITE(res, status, NU_HTTP_VER_1_0, { \"Content-Length\", get_page_size(file) }, { \"Content-Type\", content_type });\nchar *response = NU_Response_to_string(res);\n\n```\n\nIt's rather simple and elegant (in the creator's biased opinion).\n\n### Data Structures [<b>In Development</b>]\n\n####Linked List [<b>Stable</b>] Version: 1.1\n\nA generic and general use Linked List utilizing void pointers and callbacks. Sort elements, Iterate through it, and construct and deconstruct them from/to arrays! If you need a dynamic storage of elements that's thread-safe and without a real worry for optimal performance, then this is the best for you.\n\nDocumentation for version 1.0 available [here](http://theif519.github.io/Linked_List_Documentation/).\n\n####Priority Blocking Queue [<b>Stable</b>]\n\nThe Priority Blocking Queue, or DS_PBQueue, is a simple, synchronized queue that sorts elements based on the comparator passed, if there is one. If there isn't one, then it acts a normal queue, making it flexible. \n\nIt's enqueue and dequeue allows the use of a timeout, which a timeout of 0 allows you to poll, acting as a normal non-blocking queue as need be. It's synchronized nature allows it to sorted and cleared without the limits of a lockless queue, but lacks the performance of one, but overall it is moderately light weight and very intuitive and easy to use.\n\nAn example of it's use is detailed below...\n\n```c\n\n/// The comparator. Simple, as it just compares two integers.\nint compare_vals(void *arg_one, void *arg_two){\n    return *(int *)arg_one - *(int *)arg_two;\n}\n\n/// Create the queue. If the max size is 0, it is unbounded.\nDS_PBQueue_t *queue = DS_PBQueue_create(0, compare_vals);\nint num = 1;\n/// Enqueue's timeout does nothing if it is unbounded as it will never block.\nDS_PBQueue_enqueue(queue, &num, -1);\n/// Dequeue on the other handle will block if it is empty.\nDS_PBQueue_dequeue(queue, -1);\n/// Now forcefully dequeue until timeout of 5 seconds, as it is now empty.\nDS_PBQueue_dequeue(queue, 5);\n/// Now, purposefully wait undefinitely, normally this will cause a deadlock if no other thread enqueues, but observe.\nDS_PBQueue_dequeue(queue, -1);\n/// Now imagine this is called in another thread...\nDS_PBQueue_destroy(queue, free);\n/*\n    DS_PBQueue_destroy takes a callback which fits free perfectly, but any \n    other function can be used. If the queue has threads waiting on it, like \n    MU_Events, it will wake up all threads and wait for it to exit \n    appropriately before destruction.\n*/\n```\n\nNot only is the Priority Blocking Queue easy to use, but it also provides timeouts to prevent deadlocks and allow execution to come back to the user. And even on a thread waiting indefinitely, it will be woken up, preventing an eternal deadlock.\n\nVery Outdated: Documentation for version 1.0 available [here](http://theif519.github.io/Data_Structures_Documentation/Priority_Blocking_Queue/).\n\n####Vector [<b>Unimplemented</b>]\n\n####Lockless Stack [<b>Unstable</b>]\n\nThe lockless stack utilizes MU_Hazard_Pointers to avoid the ABA problem and allow safe deallocation of nodes after they are popped off the stack. The stack is guaranteed not to lock, hence all threads are constantly making progress, with the obligatory 250 microseconds of sleep to avoid thrashing the CPU. \n\nOverall, it's a simple, yet powerful thread-safe, lockless data structure.\n\n```c\n\nDS_Stack_t *stack = DS_Stack_create();\nDS_Stack_push(stack, \"Hello World\");\nDS_Stack_pop(stack);\nDS_Stack_destroy(stack);\n\n```\n\nThat's all there is to it.\n\n####Ring Buffer [<b>Unimplemented</b>]\n\n####Hash Map [<b>In Development</b>]\n\nA basic, synchronized hash map implementation. It's thread-safe, but not lockless, yet it fulfills it's purpose. It takes string keys, but it's value can be anything. \n\nAs a hash table isn't anything special, I'll give a simple demonstration of it's use below.\n\n```c\n\nconst int init_bucket_size = 31;\nconst bool synchronized = true;\n\n// Assume it just returns the string directly.\nchar *to_string(void *data);\n\nDS_Map_t *map = DS_Map_create(init_bucket_size, synchronized);\nDS_Map_add(\"Hello World\", \"How are you\");\nprintf(\"%s\", DS_Map_get(\"Hello World\"));\nsize_t key_val_size;\nchar **key_val_pairs = DS_Map_key_value_to_string(map, \"(\", \",\", \")\",&key_val_size, to_string);\n\n```\n\nOverall, it's simple and intuitive to use.\n\n####Deque [<b>Unimplemented</b>]\n\n### Misc Utils [<b>Stable</b>]\n\n####Logger [<b>Stable</b>] Version: 1.4\n\nA minimal logging utility which supports logging based on log levels, with it's own custom formatting. Also supports a custom log level with custom log label for formatting. \n\nExample: \"%tsm \\[%lvl\\](%fle:%lno) %fnc(): \\n\\\"%msg\\\"\\n\" \n\nWhich is the current default, would look like such...\n\n```c\n\nMU_Logger_t *logger = MU_Logger_create(\"Test_File.txt\", \"w\", MU_INFO);\nMU_LOG_INFO(logger, \"Hello World!\");\n\n```\n\nThe above would produce the following output:\n\n9:39:32 PM \\[INFO\\](test_file:63) main():\n\"Hello World!\"\n\nThe most notable features being that it lets you know not only the exact line number and file, but also the function it is being called from.\n\nIn the future, there will be more log formats being accepted, as well as config file support and syslog support, even a lockless ring buffer and a worker thread to manage them.\n\n####Timer [<b>Unstable</b>] Version: 1.0\n\nA basic timer utility, allowing you to start and stop a timer and get a string representation of the total time.\n\n####Events [<b>Stable</b>] Version: 1.1\n\nAn implementation of Win32 Events. As of yet, it allows you to wait on an event, which is equivalent to waiting on a condition variable, signaled by other threads. \n\nMU_Events allows you to wait on events, and supports flags which allow you to set the default state, whether or not to signal the event after a timeout, and whether or not to auto-reset the event after a thread exits the event, or after the last waiting thread leaves. \n\nMU_Events is an abstraction on top of a pthread_mutex, pthread_cond variable, and other flags. MU_Events are entirely thread safe and efficient, and also entirely flexible, coming with it's own MU_Logger support. You can also name events and pass the thread identifier to allow debugging said events easier.\n\nAn example of it's usage can be seen below...\n\n```c\n\n/// Logger for events. Assume it gets initialized and setup before calling events.\nMU_Logger_t *event_logger;\n/*\n    The event object used for signaling and waiting on events.\n    This event is named \"Test Event\" and logs to the event logger,\n    inituitively. It is signaled by default, hence those calling to wait on it\n    will return immediately. The first thread to leave this event\n    successfully, will reset the event to non-signaled state.\n*/\nMU_Event_t *event = MU_Event_create(\"Test Event\", event_logger, MU_EVENT_SIGNALED_BY_DEFAULT | MU_EVENT_AUTO_RESET);\n/// We now to want wait on this event. Thread identifier can be anything, but lets just use pthread_self.\nMU_Event_wait(event, -1, (unsigned int) pthread_self());\n/// Now some other thread signals this...\nMU_Event_signal(event, (unsigned int) pthread_self());\n/* \n    Now, we're done with said event. Destroy it. Note that if any threads are \n    waiting on it, they are woken up and can gracefully exit.\n*/\nMU_Event_destroy(event, (unsigned int) pthread_self());\n\n```\n\nOnce again, simple and easy to use. The thread_id is to help with debugging, as it is unfortunately impossible to get an actual workable number to work with for a thread, but it's irrelevant in the example. Assigning your own thread_id to any given thread you spawn makes debugging easier. Alternatively, you can just past 0 if you don't care. \n\n####Event Loop [<b>Unstable</b>] Version 0.5\n\nMU_Event_Loop, is a simple, minimal event loop, which allows you to add event sources, and have them be polled on at regular intervals. The Event Loop also has support for timed or timer events, upon which the dispatch callback will be called when it's timeout ellapses.\n\nThe Event Loop is rather simple and bare bones for now, polling once every 10ms, hence the amount of precision is very high, yet somewhat expensive, however not too much so, but does not scale well when idle and does better when it has a lot of tasks to do/poll for.\n\nThe Event Loop takes a prepare callback (to prepare any such data to be passed to an event when ready), a check callback (to check if the event is ready), a dispatch callback (to notify any threads waiting on the event), and finally a finalize callback (to destroy the user data when it is finished).\n\nAn example of it's completed state (optimistically) will look somewhat akin to this...\n\n```c\n\nvoid *prepare_event(void *data){\n    return malloc(sizeof(struct some_event_t));\n}\n\nbool check_event(void *data){\n    if(do_something_with(data)) return true;\n    return false;\n}\n\nbool dispatch_event(void *data){\n    notify_thread_waiting_on(data);\n    return true;\n}\n\nbool finalize_event(void *data){\n    free(data);\n    return true;\n}\n\nbool print_something(void *data){\n    printf(\"Something!\\n\");\n    return true;\n}\n\n/*\n    The below is an example of how to use the event loop.\n    It creates a simple event with it's appropriate callbacks,\n    then sets it's timeout to 0, meaning it is polled on once every\n    10ms. Next is a timed_event, which is will print \"Something!\" once\n    every 10 seconds.\n*/\nint main(void){\n    MU_Event_Source_t *event = MU_Event_Source_create(prepare_event, check_event, dispatch_event, finalize_event, 0);\n    MU_Event_Source_t *timed_event = MU_Event_Source_create(NULL, NULL, print_something, NULL, 10);\n    MU_Event_Loop_t *loop = NU_Event_Loop_create();\n    MU_Event_Loop_add(loop, event);\n    MU_Event_Loop_add(loop, timed_event);\n    MU_Event_Loop_run(loop);\n    return 0;\n}\n\n```\n\nIt's very simple, and as always, easy to use. Right now it's not entirely stable, but I'm working on fixing bugs and adding appropriate features.\n\n####Hazard Pointers [<b>Unstable</b>]\n\nProvides a flexible and easy to use implementation of hazard pointers, described in the research paper by Maged M. Michael, [here](http://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf).\n\nThe implementation is still in development and needing of testing, however I have an optimistic outlook on how it will look. Basically, you will \"acquire\" data via it's pointer and \"release\" it when you are finished. You must make sure to release the reference once finished with it, through the API calls MU_Hazard_Pointer_acquire() and MU_Hazard_Pointer_release and MU_Hazard_Pointer_release_all.\n\nAnother notable feature is that you do not need to keep your own reference to the hazard pointer itself, as it's allocated as thread-local storage and allocated on first use. Lastly, any remaining data not freed before the program ends, will be destroyed when the library is unlinked (I.E program termination).\n\nAn optimistic example of it's finished API looks like this...\n\n```c\n\n/*\n    For an example, lets assume the structure of a basic\n    lock-free stack.\n*/\nStack_t *stack;\n/*\n    Lets emulate a simple pop lockless procedure.\n*/\nNode_t *head, *next;\nwhile(true){\n    head = stack->head;\n    if(!head) return NULL;\n    MU_Hazard_Pointer_acquire(head);\n    if(head != stack->head){\n        MU_Hazard_Pointer_release(head);\n        usleep(250);\n        continue;\n    }\n    next = head->next;\n    if(__sync_bool_compare_and_swap(&stack->head, head, next)) break;\n    MU_Hazard_Pointer_release(head);\n    usleep(250);\n}\nvoid *data = head->item;\n// true = retire data, set to be deleted later, false = just remove reference\nMU_Hazard_Pointer_release(head, true);\n\n```\n\nThat's it. The above is a snippet of the lockfree stack I created using it. Note that each time you, must release reference to the pointer, and usleep is used to lower overall contention to prevent threashing of the CPU.\n\nOverall, it's rather simple.\n\n\n####Flags [<b>Stable</b>] Version: 1.0\n\nProvides extremely simple yet extremely useful flags for bitmasking. In fact, it is so simple, you actually do not even need to know how bitwise operations even work. They provide macros that allow you to determine if a flag is set in a mask, to set a flag, clear a flag or even toggle a flag. They are extremely simple, once again.\n\nAn example of the usage of MU_Flags are below...\n\n```c\n\n/// Sample flag, the easiest way to bitwise flags without doing the math yourself\n#define SIMPLE_FLAG 1 << 0\n/// You can also use a constant expression.\nstatic const unsigned int scope_respecting_flag = 1 << 1;\n/// Or use an enumeration\ntypedef enum {\n    flag_one = 1 << 2,\n    flag_two = 1 << 3,\n    flag_three = 1 << 4\n} flags;\n\n/// Now to show how to use the given MU_Flag macros.\n\n/// Initialize a mask of flags.\nunsigned int mask = SIMPLE_FLAG | scope_respecting_flag | flag_one;\n/// Can determine if a flag has been passed in the mask above. Will be true.\nbool has_simple_flag = MU_FLAG_GET(mask, scope_respecting_flag);\n/// Sets the flag_two flag in the mask\nMU_FLAG_SET(mask, flag_two);\n/// Removes the SIMPLE_FLAG mask from the mask\nMU_FLAG_CLEAR(mask, SIMPLE_FLAG);\n/// Toggles flag_three on.\nMU_FLAG_TOGGLE(mask, flag_three);\n\n```\n\nJust like everything else, extremely simple. They compress 5 different flags into one unsigned integer, making it very flexible when adding more. The amount of flags is dependent on the type of flag. A 16-bit short can handle 16 flags, while an integer can handle 32, while a long can handle 64 flags. Very intuitive, and easy to use.\n\n####Argument Checking [<b>Stable</b>] Version: 1.1\n\nFeatures a very simple and easy to use macro that can check up to 8 arguments, logging the conditionals as strings and whether or not they are true or false. It should be noted that due to the limitations of macros, it does not feature short-circuit evaluations, hence if you are going to be checking struct members for validity you must check each time to see if the struct exists.\n\nAn example of it's use can be seen below.\n\n```c\n\n// Assume this is initialized sometime before test_func is called.\nMU_Logger_t *logger;\n\ntypedef struct {\n    bool is_valid;\n} test_struct;\n\nbool test_func(char *msg, int val, test_struct *test){\n    MU_ARG_CHECK(logger, false, msg, val > 0 && val < 100, test, test && test->is_valid);\n    /*\n        MU_ARG_CHECK takes a logger to log to, the return value, and then up to 8 arguments. Once again note that you must short-circuit test to get it's is_valid member safely as this is a limitation of macros.\n    */\n}\n\n```\n\nIf any of the conditions fail, it will output the following. For this example, assume test's is_valid member is false.\n\nInvalid Arguments=> { msg: TRUE; val > 0 && val < 100: TRUE; test: TRUE; test && test->is_valid: FALSE }\n\nIt's very simple yet very easy to do in each function. If you have more than 8 arguments you can do more than one MU_ARG_CHECK as there are amount of arguments / 8.\n\n####Conditional Locks [<b>Stable</b>] Version: 1.0\n\nFeatures auto-logging locking macros for mutexes and rwlocks. It simply checks if the lock if NULL before attempting to lock, as attempting to lock a NULL pthread_*_t argument will cause a segmentation fault. Also should note that if something goes wrong, I.E on EDEADLK, it will log the precise location of said errors.\n\nExamples of it's use are below...\n\n```c\n\n/// Assume this gets initialized before being called.\npthread_rwlock_t *lock;\n/// Etc.\nMU_COND_RWLOCK_RDLOCK(lock, logger);\n/// Later, maybe in some other thread...\nMU_COND_RWLOCK_WRLOCK(lock, logger);\n\n```\n\nNow imagine you have a data structure that uses rwlocks, or even mutexes. Now, the overhead of a mutex, no matter how optimized they are, is still unneeded on single threaded applications for said data structure. Hence, if lock is NULL it will result in a NOP, and do nothing. The compiler may even optimize away the check entirely and act like it's not there, who knows. The point being that it allows for more flexible data structures which can't be made lockless.\n\n####Portable TEMP_FAILURE_RETRY [<b>Stable</b>] Version: 1.0\n\nAs GCC's TEMP_FAILURE_RETRY macro allows you to restart functions which return -1 and set errno to EINTR, which allow for consistent programming regardless of signals. The macro I implement is merely, an abuse of the comma operator to loop until EINTR is no longer set. It essentially is the below...\n\n```c\n\n#define MU_TEMP_FAILURE_RETRY(storage, function) while(errno = 0, storage = function, errno = EINTR)\n\n```\n\nIt's use can be noted below...\n\n```c\n\nFILE *file = fopen(...);\n/// Assume this contains a valid file.\nchar buf[BUFSIZ];\nsize_t bytes_read;\nMU_TEMP_FAILURE_RETRY(bytes_read, fread(buf, 1, BUFSIZ, file));\n/// Etc.\n\n```\n\nIt isn't as fluent as GNU's gcc macro, as I'm unsure how it is implement as it allows the return of the function call, but mine stores it inside of what's passed in storage argument.\n\n####Notice\n\nDocumentation will be split between the two later, as originally they both were contained within one file. However, the original documentation can be found below!\n\nDocumentation is also outdated, but will be updated eventually once everything is stable.\n\nDocumentation for version 1.0 available [here](http://theif519.github.io/Misc_Utils_Documentation/).\n\n## Notes\n\nNot all packages here are finished, neither do the list of packages here reflect the finished amount.\n",
			"file": "README.md",
			"file_size": 30897,
			"file_write_time": 130852054201221354,
			"settings":
			{
				"buffer_size": 30897,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Data_Structures/DS_Hash_Map.h",
			"settings":
			{
				"buffer_size": 2269,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Data_Structures/DS_Stack.c",
			"settings":
			{
				"buffer_size": 2366,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Data_Structures/Tests/DS_Stack_Test.c",
			"settings":
			{
				"buffer_size": 1097,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/Makefile/Make.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				]
			],
			[
				"Packages/C++/C++ Single File.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/User/Make_C.sublime-build",
					""
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				],
				[
					"Packages/User/Make_C.sublime-build",
					""
				]
			],
			[
				"Packages/User/Make_C.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 58.0,
		"last_filter": "make depe",
		"selected_items":
		[
			[
				"make depe",
				"Makefile (C_Utils): make depend"
			],
			[
				"make clean",
				"Build With: Make - Clean"
			],
			[
				"make depend",
				"Makefile (C_Utils): make depend"
			],
			[
				"make",
				"Makefile (C_Utils): make all"
			],
			[
				"make ",
				"Makefile (C_Utils): make depend"
			],
			[
				"git push",
				"Git: Push"
			],
			[
				"git commit",
				"Git: Commit"
			],
			[
				"git add",
				"Git: Add..."
			],
			[
				"git commt",
				"Git: Commit"
			],
			[
				"git",
				"Git: Add..."
			],
			[
				"git status",
				"Git: Status"
			],
			[
				"make clea",
				"Build With: Make - Clean"
			],
			[
				"make cl",
				"Build With: Make - Clean"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"lint",
				"SublimeLinter: Toggle Linter"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"Package",
				"Package Control: Remove Package"
			],
			[
				"Package Control: ",
				"Package Control: List Packages"
			],
			[
				"package ",
				"Package Control: Install Package"
			],
			[
				"Run",
				"Run"
			],
			[
				"run",
				"Run"
			],
			[
				"status",
				"Git: Status"
			],
			[
				"Make_C",
				"Build With: Make_C"
			],
			[
				"Package Control",
				"Package Control: List Packages"
			],
			[
				"Package Control: C",
				"Package Control: Add Channel"
			],
			[
				"Pack",
				"Preferences: Browse Packages"
			]
		],
		"width": 416.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"asda",
			"view.run_command('EventDump')",
			"view.run_command('my_app')",
			"view.run_command('myapp')",
			"view.run_command('my_app')",
			"view.run_command('myapp')",
			"view.run_command('example')",
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/theif519/Documents/GitHub/C_Utils",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Logs",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Misc",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Tests",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Logs"
	],
	"file_history":
	[
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/README.md",
		"/C/Program Files (x86)/Diablo III/.agent.db",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Hazard_Pointers.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Tests/DS_Stack_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Tests/MU_Hazard_Pointers_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Misc/DS_Stack_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_List.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Stack.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Logs/MU_Hazard_Pointers.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Stack.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Hazard_Pointers.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Misc/MU_Hazard_Pointer_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Misc/MU_Event_Loop_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_List.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Logs/DS_List.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Misc/MU_Hazard_Pointers_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Tests/DS_List_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Misc/DS_List_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Event_Loop.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Event_Loop.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Tests/Linked_List_Test.c",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/tmp.c",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/SublimeLinter.sublime-settings",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils/SU_String.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Tests/MU_Event_Loop_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Events.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/TP_Pool.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/TP_Pool.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Flags.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_HTTP.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils/SU_String.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Linked_List.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/README.md",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/Logs/MU_Event_Loop.log",
		"/C/cygwin64/usr/include/sys/types.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Tests/NU_Server_Test_File_Downloader.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Misc/Web_Pages/index.html",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Misc/Web_Pages/menu.html",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_HTTP.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Linked_List.c",
		"/C/WebBanking/web/index.html",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Logs/NU_HTTP.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Logs/NU_Server.log",
		"/C/WebBanking/web/GetBalance.jsp",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Misc/NU_Server_File_Downloader.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Logger.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Logger.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Server.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Logs/TP_Pool.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Hash_Map.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Server.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Misc/DS_Hash_Map_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Logs/DS_Hash_Map_Test.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Logs/DS_Hash_Map.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Hash_Map.h",
		"/C/cygwin64/usr/include/string.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Tests/DS_Hash_Map_Test.c",
		"/C/cygwin64/usr/include/sched.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Helper.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Connection.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Client.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Client.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Connection.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Helper.c",
		"/C/Users/theif519/Documents/theif519.html",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils/Tests/SU_String_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils/Logs/SU_String_Test.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils/Logs/SU_String.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/C_Utils.sublime-project",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Test.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Arg_Check.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/String_Utils/Misc/SU_String_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Arg_Check.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Queue.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Queue.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Events.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Misc/TP_Pool_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Test/TP_Pool_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Logs/TP_Pool_Events.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Logs/TP_Pool_Test.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Tests/DS_PBQueue_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_PBQueue.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_PBQueue.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Misc/DS_PBQueue_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Logs/DS_PBQueue_Test.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Helpers.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Thread_Pool.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Thread_Pool.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/PBQueue.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/PBQueue.c",
		"/C/cygwin64/usr/include/sys/signal.h",
		"/C/cygwin64/usr/include/sys/tree.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Code/Thread_Pool.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Thread_Pool/Code/Thread_Pool.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Tests/NU_Server_Test_Client_Chat.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/NU_Server.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Hash_Map_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Misc/NU_HTTP_Header_Test.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Tests/NU_HTTP_Header_Test.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Misc/NU_Server_Telnet_Client_Chat.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Cond_Locks.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Cond_Locks.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Tests/NU_Client_Test_File_Downloader.c",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/Misc/NU_Server_Telnet_Client_Char.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/MU_Retry.h",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Misc/DS_Hash_Map.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/NU_Server_File_Downloader.mk",
		"/C/Users/theif519/Documents/GitHub/C_Utils/DS_Hash_Map_Test.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/DS_Hash_Map.log",
		"/C/Users/theif519/Documents/GitHub/C_Utils/DS_Hash_Map_Test.exe.stackdump",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Makefile",
		"/C/cygwin64/home/theif519/DrMemory-Linux-1.8.0-8/README",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Net_Utils/makefile",
		"/C/Users/theif519/Documents/GitHub/C_Utils/COMMIT_EDITMSG.COMMIT_EDITMSG",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Misc_Utils/COMMIT_EDITMSG.COMMIT_EDITMSG",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/SublimeLinter-contrib-clang/README.md",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/DS_Hash_Map.sublime-project",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/SublimeLinter/SublimeLinter.sublime-settings",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/SublimeLinter/Default (Windows).sublime-keymap",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/Prefixr/My_First_Plugin.py",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/Default (Windows).sublime-keymap",
		"/C/Users/theif519/Documents/GitHub/C_Utils/make.sh",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/C_Make.sublime-build",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/C_Build.sublime-build",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/Make_C.sublime-build",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/User/MakeCommand.sublime-commands",
		"/C/Users/theif519/AppData/Roaming/Sublime Text 3/Packages/Git/Git.sublime-settings",
		"/C/Users/theif519/Documents/GitHub/C_Utils/Data_Structures/Hash_Map/DS_Hash_Map_Test.c"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 90.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"MU_HP_List_t",
			"pthread_rwlock_destroy\\(list->manipulating_list\\);",
			"pthread_rwlock_destroy\\(list->manipulating_iterator\\);",
			"pthread_rwlock_destroy(list->manipulating_iterator);",
			"pthread_rwlock_rdlock\\(list->manipulating_iterator\\);",
			"pthread_rwlock_rdlock\\(list->manipulating_list\\);",
			"pthread_rwlock_unlock\\(list->manipulating_iterator\\);",
			"pthread_rwlock_unlock\\(list->manipulating_list\\);",
			"pthread_rwlock_wrlock\\(list->manipulating_iterator\\);",
			"pthread_rwlock_wrlock\\(list->manipulating_list\\);",
			"pthread_rwlock_wrlock(list->manipulating_list\\);",
			"pthread_rwlock_wrlock(list->manipulating_list);",
			"pthread_rwlock_wrlock\\(list->manipulating_list\\);",
			"Linked_List",
			"Linked_List_delete",
			"->prev",
			"prev",
			"->next",
			"Linked_List_Compare",
			"delete_item",
			"Node_t",
			"Linked_List_t",
			"time_t",
			"_TIME_T_",
			"stat",
			"file_path",
			"meth",
			"ver",
			"DS_HASH_MAP_KEY_SIZE",
			"\\\\n",
			"\\\\\"",
			"select\\(",
			"select",
			"timed",
			"substring",
			"string",
			"substring",
			"string",
			"SU_String_t",
			"SU_String_t \\*",
			"SU_String_t  *",
			"U_String_t  *",
			"SU_String_t *",
			"SU_String_t \\*",
			"String_t",
			"String",
			"char \\*",
			"char *",
			"char \\*",
			"String_Utils",
			"is_selected",
			"{\n",
			"is_selected",
			"thread",
			"thread_t",
			"pid_t",
			"uint32_t",
			"MU_event_signal",
			"bounds",
			"pthread",
			"strerror",
			"pthread_mutex_t",
			"pthread_cond_t",
			"malloc",
			"}\n",
			"signal_event",
			"cond",
			"flag",
			"lock",
			"no_tasks",
			"bsock->is_bound",
			", logger",
			", MU_Logger_t \\*logger",
			"\\(logger",
			", MU_Logger_t \\*logger",
			", logger",
			"// Implement",
			"			\n",
			"\\\\n",
			"\\\\\"",
			"MU_Cond_rwlock_unlock",
			"MU_Cond_rwlock_wrlock",
			"MU_Cond_rwlock_rdlock",
			"MU_Cond_rwlock_destroy",
			"MU_Cond_rwlock_init",
			"MU_Cond_rwlock_unlock",
			"MU_Cond_rwlock_rdlock",
			"MU_Cond_rwlock_wrlock",
			"MU_Cond_rwlock_destroy",
			"MU_Cond_rwlock_wrlock",
			"MU_Cond_rwlock_rdlock",
			"MU_Cond_rwlock_unlock",
			"MU_Cond_rwlock_destroy",
			"MU_Cond_rwlock_wrlock",
			"MU_Cond_rwlock_rdlock",
			"(^\\\\r)\\\\n\"",
			"\\\\n\"",
			"\\\\\"",
			"MU_Cond_rwlock_de",
			"\".*->",
			"\"NU_Client_destroy->",
			"\".*->",
			" != NULL",
			"!= NULL",
			" != NULL",
			"!= NULL",
			"\\(\\(void \\*\\)0\\)",
			"((void *)0)",
			"'\\n\"",
			"'\\\\n\"",
			"\\\\n",
			"\\\\\"",
			"\"NU_.*->",
			"\".*->",
			"\"NU_Server_destroy->",
			"\".*->",
			"\\\\\"",
			"\\\\n\"",
			"\\\\\"",
			"\\\\n",
			"MU_TEMP_",
			"'",
			"\\\\n",
			"\\n",
			"\\\\n",
			"MU_logger_Log",
			"assertion",
			"__LINE__"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"MU_Hazard_Pointer_List_t",
			"MU_COND_RWLOCK_DESTROY(list->manipulating_list, logger);",
			"MU_COND_RWLOCK_DESTROY(list->manipulating_iterator, logger);",
			"MU_COND_RWLOCK_RDLOCK(list->manipulating_iterator, logger);",
			"MU_COND_RWLOCK_RDLOCK(list->manipulating_list, logger);",
			"MU_COND_RWLOCK_UNLOCK(list->manipulating_iterator, logger);",
			"MU_COND_RWLOCK_UNLOCK(list->manipulating_list, logger);",
			"MU_COND_RWLOCK_WRLOCK(list->manipulating_iterator, logger);",
			"MU_COND_RWLOCK_WRLOCK(list->manipulating_list, logger);",
			"MU_COND_RWLOCK(list->manipulating_list, logger);",
			"DS_List",
			"DS_delete_cb",
			"->_double.prev",
			"->_double.next",
			"DS_comparator_cb",
			"del",
			"DS_Node_t",
			"DS_List_t",
			"status",
			"path",
			"method",
			"version",
			"",
			"'",
			"substr",
			"str",
			"substr",
			"str",
			"String",
			"SU_String_t ",
			"SU_String_t",
			"String_t",
			"String ",
			"String",
			"SU_String",
			"MU_FLAG_GET",
			"__uint32_t",
			"max_size",
			"event_signal",
			"signal_event",
			"signaled",
			"event_lock",
			"",
			"(conn->logger",
			"",
			", conn->logger",
			"",
			"'",
			"MU_COND_RWLOCK_UNLOCK",
			"MU_COND_RWLOCK_WRLOCK",
			"MU_COND_RWLOCK_RDLOCK",
			"MU_COND_RWLOCK_DESTROY",
			"MU_COND_RWLOCK_INIT",
			"MU_COND_RWLOCK_UNLOCK",
			"MU_COND_RWLOCK_RDLOCK",
			"MU_COND_RWLOCK_WRLOCK",
			"MU_COND_RWLOCK_DESTROY",
			"MU_COND_RWLOCK_WRLOCK",
			"MU_COND_RWLOCK_RDLOCK",
			"MU_COND_RWLOCK_UNLOCK",
			"MU_COND_RWLOCK_DESTROY",
			"MU_COND_RWLOCK_WRLOCK",
			"MU_COND_RWLOCK_RDLOCK",
			"\"",
			"",
			"\"",
			"",
			"NULL",
			"\"",
			"",
			"'",
			"\"",
			"'",
			"\"",
			"'",
			"",
			"\"",
			"",
			"MU_LOGGER_STRINGIFY(__LINE__)",
			"MU_Arg_evaluate_boolean(arg)",
			"",
			"string_ptr, arg",
			"bool",
			"DS_Bucket_t",
			"=",
			"[$1]",
			"",
			"NU_Server",
			"server",
			"NU_Server_t",
			"MU_Cond_rwlock",
			"NU_Connection_t",
			"connections",
			"conn",
			"NU_Connection_t *",
			"conn",
			"connections",
			"NU_Connection_t **",
			"NU_Connection_t *connection",
			"Atomic",
			"(conn->lock, logger)",
			"NU_unlock_rwlock",
			"NU_Connection_t *",
			"conn",
			"NU_Connection_t **",
			"NU_Connection_t **connections",
			"NU_Connection_t *connection",
			"NU_Connection_t **",
			"NU_Connection_t **connections",
			"NU_Connection_t *connection",
			"1.0",
			"",
			"(errno)",
			"errno",
			"ip_addr",
			"bbuf",
			"ip_addr",
			"bbuf",
			"NU_Bounded_Buffer_t",
			"bbuf",
			"MU_Get_Timestamp",
			"client->sockfd",
			"logger",
			"MU_LOG_VERBOSE(logger, ",
			"\\nTesting:",
			"Testing: %s",
			"",
			"\\\"%s\\\""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30897,
						"regions":
						{
						},
						"selection":
						[
							[
								311,
								311
							]
						],
						"settings":
						{
							"syntax": "Packages/MarkdownEditing/Markdown.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 10152.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Data_Structures/DS_Hash_Map.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2269,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Data_Structures/DS_Stack.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2366,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "Data_Structures/Tests/DS_Stack_Test.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1097,
						"regions":
						{
						},
						"selection":
						[
							[
								423,
								423
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": -0.0,
						"translation.y": 126.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 157.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "C_Utils.sublime-project",
	"replace":
	{
		"height": 62.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 196.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
